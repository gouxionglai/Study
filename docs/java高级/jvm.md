# JVM

# 字节码底层原理

JVM虚拟机

内存模型：堆，(线程)栈，本地方法栈，方法区，程序计数器

jdk自带反汇编

javap -c xxx.class

程序计数器：主要作用在多线程情况下标记程序执行到的位置

字节码执行引擎：修改程序计数器的值



## 栈

FILO  先入后出，main最开始执行，最后执行完毕。

### 栈帧：

#### 局部变量表

存放局部变量的值

#### 操作数栈

临时内存区域

#### 动态连接

#### 方法出口

​	方法返回到哪个位置，由程序计数器决定

## 堆

### 内存空间结构

名称：年轻代：老年代

内存占比：	1/3： 2/3

#### 年轻代

进一步分为：Eden， Servivor区 (分为s0, s1)

内存占比：   8/10， 1/10，   1/10	

年轻代的Eden内存满了触发minor GC。

#### 老年代

每一次minor GC扫描发现有引用，则对象头的对象分代年龄+1；如果达到15，则放入老年代。minor GC不会扫描。

老年代内存满了触发full GC。



## GC

当堆内存满了，则自动触发GC，回收内存空间

### GC root

可达性算法。

一系列的链表结构，用来判别是否有引用。如果没有引用则会被视为垃圾，从而回收掉。

### minor GC

检查eden区域，servivor区域。

常用的判断方法有可达性算法，标记有引用的内存区域，其他没有用的就清除掉。

eden中有引用的挪到servivor（具体是s0,还是s1看当前位置）

s0有引用的挪到s1（交替，始终保持一个是空的。比如此时在s1，s0是空的，则把s1还在引用的，和eden中有引用的挪到s0, 对象分代年龄计数+1）

### full GC

当老年代内存占满的时候，触发全体清空，清空年轻代+老年代。

如果回收失败，则抛出异常OutOfMemery。  oom

比如在局部方法里面，无限次new对象，引用对象。常见的有递归。



### STW

full GC的时候会将用户线程挂载起来，去进行fullGC, 所以用户会感觉到卡顿。但是通常GC操作非常快。

我们称这个卡顿为STW（stop the world）

- 为什么需要STW,  单线程GC操作去遍历GCroot更快，保证之前扫描过的数据是正确的，而不是时刻变化的。
- 为什么需要jvm调优，就是优化full GC，去减少STW的时间，增强用户体验。



## JVM调优

需要具体场景具体分析，比如电商系统，下单之后产生很多没用的对象。就应该适当增加年轻代的空间，减少老年代的空间。







聚集索引：：索引和数据存储在一起，即key对应的value就是用户想要的值。

非聚集索引：索引和数据分开存储，即key对应的value存的是地址，另一个文件里面去根据值找



聚集索引的好处是减少磁盘交互，减少查询时间。增加查询效率。虽然都是B+Tree的存储方式，但是非聚集索引找到存储的位置之后还需要到另一个文件去找对应的value，而聚集索引直接就把key对应的value拿出来了



主键索引推荐自增，而且是整型的原因是 减少分裂的情况。因为如果没有按顺序插入，那么会给b+tr